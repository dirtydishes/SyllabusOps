import fs from "node:fs/promises";
import path from "node:path";
import { resolveWithinRoot } from "@syllabusops/core";
import { z } from "zod";
import type { LibrarySession } from "../library/library";
import { listTextbookCatalog } from "../textbooks/index";
import type { SectionRow } from "./store";

const TextbookIndexSchema = z.object({
  version: z.literal(1),
  source: z.object({
    relPath: z.string().nullable(),
    sessionDate: z.string().nullable(),
  }),
  chunks: z.array(
    z.object({
      text: z.string(),
    })
  ),
});

function sessionInRange(
  sessionDate: string,
  startDate: string,
  endDate: string
): boolean {
  return sessionDate >= startDate && sessionDate <= endDate;
}

function summarizeSessionMarkdown(input: string): string {
  const lines = input
    .replaceAll(/\r\n?/g, "\n")
    .split("\n")
    .map((ln) => ln.trim())
    .filter(Boolean)
    .filter((ln) => !ln.startsWith("#"))
    .filter((ln) => !ln.startsWith("**Session:**"))
    .filter((ln) => !ln.startsWith("**Generated:**"))
    .filter((ln) => !ln.startsWith("> "));
  const text = lines.join(" ");
  if (!text) return "No summary excerpt available.";
  if (text.length <= 420) return text;
  return `${text.slice(0, 420).trim()}...`;
}

function summarizeTextbookChunk(input: string): string {
  const text = input.replaceAll(/\s+/g, " ").trim();
  if (!text) return "No chunk text available.";
  if (text.length <= 340) return text;
  return `${text.slice(0, 340).trim()}...`;
}

function sectionDocRelPath(opts: { courseSlug: string; sectionSlug: string }) {
  return `${opts.courseSlug}/generated/sections/${opts.sectionSlug}/unified-study-doc.md`;
}

export async function generateUnifiedSectionDoc(opts: {
  unifiedDir: string;
  stateDir: string;
  course: { slug: string; name: string };
  section: SectionRow;
  sessions: LibrarySession[];
}): Promise<{
  relPath: string;
  absolutePath: string;
  sessionCount: number;
  textbookCount: number;
}> {
  const inRangeSessions = opts.sessions.filter((s) =>
    sessionInRange(s.date, opts.section.start_date, opts.section.end_date)
  );
  const textbooks = (
    await listTextbookCatalog({
      stateDir: opts.stateDir,
      courseSlug: opts.course.slug,
    })
  ).filter((entry) => {
    if (!entry.sessionDate) return true;
    return sessionInRange(
      entry.sessionDate,
      opts.section.start_date,
      opts.section.end_date
    );
  });

  const relPath = sectionDocRelPath({
    courseSlug: opts.course.slug,
    sectionSlug: opts.section.slug,
  });
  const resolved = resolveWithinRoot(opts.unifiedDir, relPath);
  if (!resolved.ok) throw new Error("SECTION_DOC_PATH_DENIED");

  const lines: string[] = [];
  lines.push(`# ${opts.course.name} â€” ${opts.section.title}`);
  lines.push("");
  lines.push(`**Course:** ${opts.course.name} (${opts.course.slug})`);
  lines.push(
    `**Date range:** ${opts.section.start_date} to ${opts.section.end_date}`
  );
  lines.push(`**Generated:** ${new Date().toISOString()}`);
  lines.push("");
  lines.push(
    "> This file is generated by SyllabusOps. Put manual edits in section notes."
  );
  lines.push("");
  if (opts.section.description?.trim()) {
    lines.push("## Section focus");
    lines.push(opts.section.description.trim());
    lines.push("");
  }

  lines.push("## Coverage");
  lines.push(`- Sessions included: ${inRangeSessions.length}`);
  lines.push(
    `- Artifacts included: ${inRangeSessions.flatMap((s) => s.artifacts).length}`
  );
  lines.push(`- Textbooks indexed: ${textbooks.length}`);
  lines.push("");

  lines.push("## Session summaries");
  if (inRangeSessions.length === 0) {
    lines.push("_(none in selected range)_");
    lines.push("");
  } else {
    for (const session of inRangeSessions.sort((a, b) =>
      a.date.localeCompare(b.date)
    )) {
      const summaryRelPath = `${opts.course.slug}/generated/sessions/${session.date}/session-summary.md`;
      const summaryAbs = path.join(opts.unifiedDir, summaryRelPath);
      let summaryExcerpt = "No generated session summary found.";
      try {
        const raw = await fs.readFile(summaryAbs, "utf8");
        summaryExcerpt = summarizeSessionMarkdown(raw);
      } catch {}

      lines.push(`### ${session.date}`);
      lines.push(`- Session summary: \`${summaryRelPath}\``);
      lines.push(`- Artifact count: ${session.artifacts.length}`);
      for (const artifact of session.artifacts) {
        lines.push(`  - ${artifact.fileName} (${artifact.kind})`);
      }
      lines.push("");
      lines.push(summaryExcerpt);
      lines.push("");
    }
  }

  lines.push("## Textbook chapter summaries");
  if (textbooks.length === 0) {
    lines.push("_(none indexed for this range yet)_");
    lines.push("");
  } else {
    for (const textbook of textbooks.sort((a, b) =>
      (a.relPath ?? a.sha256).localeCompare(b.relPath ?? b.sha256)
    )) {
      const indexPath = path.join(
        opts.stateDir,
        "cache",
        "textbooks",
        `${textbook.sha256}.index.json`
      );
      let chunkSummary = "No indexed chunk text available.";
      try {
        const parsed = TextbookIndexSchema.parse(
          JSON.parse(await fs.readFile(indexPath, "utf8"))
        );
        chunkSummary = summarizeTextbookChunk(parsed.chunks[0]?.text ?? "");
      } catch {}

      lines.push(`### ${textbook.relPath ?? textbook.sha256}`);
      if (textbook.sessionDate)
        lines.push(`- Session date: ${textbook.sessionDate}`);
      lines.push(`- Chunks indexed: ${textbook.chunks}`);
      lines.push(`- Source chars: ${textbook.sourceTextChars}`);
      lines.push("");
      lines.push(chunkSummary);
      lines.push("");
    }
  }

  await fs.mkdir(path.dirname(resolved.absolutePath), { recursive: true });
  await fs.writeFile(resolved.absolutePath, `${lines.join("\n")}\n`, "utf8");

  return {
    relPath,
    absolutePath: resolved.absolutePath,
    sessionCount: inRangeSessions.length,
    textbookCount: textbooks.length,
  };
}
